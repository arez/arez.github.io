<html><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1"/><title>Blog Â· Arez</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta property="og:title" content="Blog Â· Arez"/><meta property="og:type" content="website"/><meta property="og:url" content="https://arez.github.io/index.html"/><meta property="og:description" content="Fast, easy, reactive state"/><link rel="shortcut icon" href="/img/favicon-32x32.png"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/idea.min.css"/><link rel="alternate" type="application/atom+xml" href="https://arez.github.io/blog/atom.xml" title="Arez Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://arez.github.io/blog/feed.xml" title="Arez Blog RSS Feed"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><link rel="stylesheet" href="/css/main.css"/></head><body><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="/img/logo.svg"/><h2 class="headerTitle">Arez</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li><a href="/docs/overview.html" target="_self">Docs</a></li><li><a href="/api" target="_self">API</a></li><li><a href="/blog" target="_self">Blog</a></li><li><a href="https://github.com/arez/arez/releases" target="_blank">Releases</a></li><li><a href="https://github.com/arez/arez" target="_blank">GitHub</a></li><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search"/></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><i></i></div><h2><i>â€º</i><span>Recent Posts</span></h2></div><div class="navGroups"><div class="navGroup navGroupActive"><h3>Recent Posts</h3><ul><li class="navListItem"><a class="navItem" href="/blog/2020/02/21/version-0.170-release.html">Arez 0.170 released</a></li><li class="navListItem"><a class="navItem" href="/blog/2020/02/18/version-0.169-release.html">Arez 0.169 released</a></li><li class="navListItem"><a class="navItem" href="/blog/2020/02/16/version-0.168-release.html">Arez 0.168 released</a></li><li class="navListItem"><a class="navItem" href="/blog/2020/02/10/version-0.167-release.html">Arez 0.167 released</a></li><li class="navListItem"><a class="navItem" href="/blog/2020/01/16/version-0.166-release.html">Arez 0.166 released</a></li></ul></div></div></section></div><script>
          var toggler = document.getElementById('navToggler');
          var nav = document.getElementById('docsNav');
          toggler.onclick = function() {
            nav.classList.toggle('docsSliderActive');
          };
        </script></nav></div><div class="container mainContainer documentContainer postContainer blogContainer"><div class="wrapper"><div class="posts"><div class="post"><header class="postHeader"><h1><a href="/blog/2018/10/19/version-0.110-release.html">Arez 0.110 released</a></h1><p class="post-meta">October 19, 2018</p><div class="authorBlock"><p class="post-authorName"><a href="https://github.com/arez" target="_blank">Arez Project</a></p></div></header><article class="post-content"><div><span><p><a href="https://github.com/arez/arez/compare/v0.109...v0.110">Full Changelog</a></p>
<p>Changes in this release:</p>
<ul>
<li><strong>[core]</strong> Add the parameter <code>writeOutsideTransaction</code> to the <code>@Observable</code> annotation that makes it
possible to define observable properties that will create an action if they are not already wrapped in
a transaction. This simplifies scenario where actions are only being created to modify a single
observable value.</li>
<li><strong>[docs]</strong> Add some minimal user documentation about <code>@Reference</code> and <code>@Inverse</code> annotations.</li>
<li><strong>[core]</strong> Add <code>&lt;inherits name='arez.Arez'/&gt;</code> to the <code>Component.gwt.xml</code> GWT module so no need
to explicitly inherit module in downstream applications.</li>
<li><strong>[processor]</strong> Generate a compile error if an <code>@Observable</code> annotated method is abstract and throws
an exception.</li>
<li><strong>[processor]</strong> Add the <code>depType</code> parameter to the <code>@Memoize</code> annotation.</li>
</ul>
</span></div></article></div><div class="post"><header class="postHeader"><h1><a href="/blog/2018/10/08/version-0.109-release.html">Arez 0.109 released</a></h1><p class="post-meta">October 8, 2018</p><div class="authorBlock"><p class="post-authorName"><a href="https://github.com/arez" target="_blank">Arez Project</a></p></div></header><article class="post-content"><div><span><p><a href="https://github.com/arez/arez/compare/v0.108...v0.109">Full Changelog</a></p>
<p>Changes in this release:</p>
<ul>
<li><strong>[core]</strong> Document the requirement for transactions on the methods: <code>ObservableValue.reportObserved()</code>,
<code>ObservableValue.preReportChanged()</code>, <code>ObservableValue.reportChanged()</code>, <code>ComputedValue.get()</code> and
<code>ComputedValue.reportPossiblyChanged()</code>.</li>
<li><strong>[core]</strong> Ensure that when the <code>ReactionEnvironment</code> functional interface is used to wrap actions that
the action can not be nested. If <code>ArezContext.runInEnvironment(action)</code> is invoked when an instance of the
<code>ReactionEnvironment</code> functional interface is already on the call stack then the supplied procedure is directly
invoked without invoking the <code>ReactionEnvironment</code> functional interface again.</li>
<li><strong>[core]</strong> Modify the <code>ReactionEnvironment</code> interface so that it executes <code>Function</code> and <code>SafeFunction</code>
instances rather than instances of <code>Procedure</code>. This will stop <code>ReactionEnvironment</code> from being a functional
interface but is preparation to enable actions to be optionally invoked inside an environment.</li>
<li><strong>[core]</strong> Add a compile-time setting <code>arez.enable_environments</code> that will mean allows the removal of the
<code>ReactionEnvironment</code> interface and related code if the feature is not needed.</li>
<li><strong>[core]</strong> Rename the <code>ReactionEnvironment</code> interface to <code>Environment</code></li>
<li><strong>[core]</strong> Add the flags <code>Flags.ENVIRONMENT_REQUIRED</code> and <code>Flags.ENVIRONMENT_REQUIRED</code>. These flags can be
supplied
<ul>
<li>when invoking actions via <code>ArezContext.action(...)</code> or <code>ArezContext.safeAction(...)</code></li>
<li>when creating <code>ComputedValue</code> instances.</li>
<li>when creating <code>Observer</code> instances that also created with the <code>Flags.APPLICATION_EXECUTOR</code> flag.
If the <code>Flags.ENVIRONMENT_REQUIRED</code> is specified then the runtime will ensure that the relevant code is
invoked within the context of the <code>Environment</code>.</li>
</ul></li>
<li><strong>[core]</strong> Rename the <code>@Observed</code> annotation to <code>@Observe</code>.</li>
<li><strong>[core]</strong> Verify the flags passed to the <code>ArezContext.action(...)</code> and <code>ArezContext.safeAction(...)</code>
have no incompatible flag combinations.</li>
<li><strong>[core]</strong> Add the <code>requireEnvironment</code> parameter to the <code>@Action</code> annotation to control whether the
<code>Flags.ENVIRONMENT_REQUIRED</code> flag is added when invoking the action.</li>
<li><strong>[core]</strong> Add the <code>requireEnvironment</code> parameter to the <code>@Computed</code> annotation to control whether the
<code>Flags.ENVIRONMENT_REQUIRED</code> flag is added when computing the value.</li>
<li><strong>[core]</strong> Add the <code>requireEnvironment</code> parameter to the <code>@Observe</code> annotation to control whether the
<code>Flags.ENVIRONMENT_REQUIRED</code> flag is added when observing a method that has an <code>APPLICATION</code> executor.</li>
<li><strong>[core]</strong> Add the <code>requireEnvironment</code> parameter to the <code>@Memoize</code> annotation to control whether the
<code>Flags.ENVIRONMENT_REQUIRED</code> flag is added when computing the value.</li>
</ul>
</span></div></article></div><div class="post"><header class="postHeader"><h1><a href="/blog/2018/09/27/version-0.108-release.html">Arez 0.108 released</a></h1><p class="post-meta">September 27, 2018</p><div class="authorBlock"><p class="post-authorName"><a href="https://github.com/arez" target="_blank">Arez Project</a></p></div></header><article class="post-content"><div><span><p><a href="https://github.com/arez/arez/compare/v0.107...v0.108">Full Changelog</a></p>
<p>Changes in this release:</p>
<ul>
<li><strong>[core]</strong> Improve the javadocs descriptions for <code>arez.Disposable</code> to bring them inline with latest
application architecture.</li>
<li><strong>[core]</strong> Ensure that the <code>apiInvariant(...)</code> invocation in <code>arez.Disposable</code> is guarded by an
<code>Arez.shouldCheckApiInvariants()</code> check. This improves dead code removal in the GWT2.x compiler.</li>
<li><strong>[core]</strong> Enhance the <code>@ComponentDependency</code> so that it can be applied to final fields.</li>
<li><strong>[processor]</strong> Generate a compile error if the <code>@CascadeDispose</code> and any other arez annotation
appears on the same method.</li>
<li><strong>[core]</strong> Cleanup documentation for the <code>@OnDepsChanged</code> method to remove references to the
<code>@Track</code> annotation that has been removed.</li>
<li><strong>[core]</strong> Enhance the <code>@CascadeDispose</code> annotation so that it can be applied to final methods.</li>
</ul>
</span></div></article></div><div class="post"><header class="postHeader"><h1><a href="/blog/2018/09/21/version-0.107-release.html">Arez 0.107 released</a></h1><p class="post-meta">September 21, 2018</p><div class="authorBlock"><p class="post-authorName"><a href="https://github.com/arez" target="_blank">Arez Project</a></p></div></header><article class="post-content"><div><span><p><a href="https://github.com/arez/arez/compare/v0.106...v0.107">Full Changelog</a></p>
<p>Changes in this release:</p>
<ul>
<li><strong>[processor]</strong> The invariant check generated to link references was being generated outside of the
associated guard. This could result in dead-code not being eliminated in GWT2.x and triggered warnings
in source code analysis programs such as spotbugs.</li>
<li><strong>[gwt-output-qa]</strong> Add assertion to verify that the <code>arez.*Info</code> interfaces are not present if
<code>Arez.areSpiesEnabled()</code> returns false.</li>
<li><strong>[core]</strong> Remove the <code>onDispose</code> parameter from the <code>ArezContext.autorun(...)</code> methods and the
<code>ArezContext.computed(...)</code> methods. This hook method was never used from within the component model
and infrequently used (if ever) from the raw API. Removing it reduced code complexity and size.</li>
<li><strong>[core]</strong> Add invariant to ensure that the parameter <code>runImmediately</code> parameter can only be <code>true</code>
if <code>keepAlive</code> parameter is <code>true</code> when creating computed values via the <code>ArezContext.computed(...)</code>
methods.</li>
<li><strong>[core]</strong> Changed the default value for the <code>runImmediately</code> parameter passed to the
<code>ArezContext.autorun(...)</code> to be <code>true</code>. Previously the default value was <code>false</code> if the <code>autorun(...)</code>
method variant had a <code>component</code> parameter but otherwise the default value was <code>true</code>.</li>
<li><strong>[core]</strong> Refactor the internal representation of runtime and configuration flags within <code>arez.Observer</code>
instances. Previously the internal state was represented by several internal variables. This resulted in
significant memory pressure when an application consisted of many observers. These configuration values
have been collapsed into a single bit field. The fields that were collapsed include the configuration
values: <code>_mode</code>, <code>_priority</code>, <code>_observeLowerPriorityDependencies</code>, <code>_canNestActions</code> and
<code>_arezOnlyDependencies</code>. The runtime fields collapsed into the bit field include: <code>_state</code>, <code>_scheduled</code> and
<code>_executeTrackedNext</code>. The <code>ComputedValue._keepAlive</code> field has also been merged into the bit field.</li>
<li><strong>[core]</strong> Remove the method <code>Spy.getObservers(ObservableValue)</code> that was replaced by <code>ObservableValueInfo.getObservers()</code>.</li>
<li><strong>[core]</strong> Remove the method <code>Spy.asComputedValue(ObservableValue)</code> that was replaced by <code>ObservableValueInfo.asComputedValue()</code>.</li>
<li><strong>[core]</strong> Remove the method <code>Spy.asComputedValue(ObservableValue)</code> that was replaced by <code>ObservableValueInfo.asComputedValue()</code>.</li>
<li><strong>[core]</strong> Remove the method <code>Spy.getComponent(ObservableValue)</code> that was replaced by <code>ObservableValueInfo.getComponent()</code>.</li>
<li><strong>[core]</strong> Remove the method <code>Spy.getValue(ObservableValue)</code> that was replaced by <code>ObservableValueInfo.getValue()</code>.</li>
<li><strong>[core]</strong> Remove the method <code>Spy.hasAccessor(ObservableValue)</code> that was replaced by <code>ObservableValueInfo.hasAccessor()</code>.</li>
<li><strong>[core]</strong> Remove the method <code>Spy.hasMutator(ObservableValue)</code> that was replaced by <code>ObservableValueInfo.hasMutator()</code>.</li>
<li><strong>[core]</strong> Remove the method <code>Spy.setValue(ObservableValue,Object)</code> that was replaced by <code>ObservableValueInfo.setValue(Object)</code>.</li>
<li><strong>[core]</strong> Remove the method <code>Spy.isReadOnly(Observer)</code> that was replaced by <code>ObserverInfo.isReadOnly()</code>.</li>
<li><strong>[core]</strong> Remove the method <code>Spy.isScheduled(Observer)</code> that was replaced by <code>ObserverInfo.isScheduled()</code>.</li>
<li><strong>[core]</strong> Remove the method <code>Spy.isRunning(Observer)</code> that was replaced by <code>ObserverInfo.isRunning()</code>.</li>
<li><strong>[core]</strong> Remove the method <code>Spy.getDependencies(Observer)</code> that was replaced by <code>ObserverInfo.getDependencies()</code>.</li>
<li><strong>[core]</strong> Remove the method <code>Spy.asComputedValue(Observer)</code> that was replaced by <code>ObserverInfo.asComputedValue()</code>.</li>
<li><strong>[core]</strong> Remove the method <code>Spy.isComputedValue(Observer)</code> that was replaced by <code>ObserverInfo.isComputedValue()</code>.</li>
<li><strong>[core]</strong> Remove the method <code>Spy.getComponent(Observer)</code> that was replaced by <code>ObserverInfo.getComponent()</code>.</li>
<li><strong>[core]</strong> Remove the method <code>Spy.isComputing(ComputedValue)</code> that was replaced by <code>ComputedValueInfo.isComputing()</code>.</li>
<li><strong>[core]</strong> Remove the method <code>Spy.getDependencies(ComputedValue)</code> that was replaced by <code>ComputedValueInfo.getDependencies()</code>.</li>
<li><strong>[core]</strong> Remove the method <code>Spy.getComponent(ComputedValue)</code> that was replaced by <code>ComputedValueInfo.getComponent()</code>.</li>
<li><strong>[core]</strong> Remove the method <code>Spy.isActive(ComputedValue)</code> that was replaced by <code>ComputedValueInfo.isActive()</code>.</li>
<li><strong>[core]</strong> Remove the method <code>Spy.getObservers(ComputedValue)</code> that was replaced by <code>ComputedValueInfo.getObservers()</code>.</li>
<li><strong>[core]</strong> Remove the method <code>Spy.getValue(ComputedValue)</code> that was replaced by <code>ComputedValueInfo.getValue()</code>.</li>
<li><strong>[core]</strong> Rename the <code>ArezContext.autorun(...)</code> methods to <code>ArezContext.observer(...)</code> and change the way
configuration is passed into to be flags so that it matches the underlying representation of configuration.</li>
<li><strong>[core]</strong> Refactor the <code>ArezContext.tracker(...)</code> methods to change the way configuration is passed into to
be flags so that it matches the underlying representation of configuration.</li>
<li><strong>[core]</strong> Refactor the internal representation of configuration flags within <code>arez.component.MemoizeCache</code> to
use a bit mask so it is easy to pass flags when creating the underlying <code>ComputedValue</code> instances.</li>
<li><strong>[core]</strong> Refactor the <code>ArezContext.computed(...)</code> methods to change the way configuration is passed into to
be flags so that it matches the underlying representation of configuration.</li>
<li><strong>[core]</strong> Move <code>arez.Spy</code> to <code>arez.spy.Spy</code> and <code>arez.SpyEventHandler</code> to <code>arez.spy.SpyEventHandler</code> so that
the Arez Spy API is located in a single package.</li>
<li><strong>[core]</strong> Remove the <code>TYPE</code> field from the spy events that is a constant derived at runtime and instead inline
the constant where it is used.</li>
<li><strong>[core]</strong> Add <code>setterAlwaysMutates</code> parameter to <code>@Observable</code> that defaults to true. If set to false then the
generated code for the setter will check that the setter actually made a change to the observable value before
propagating the change. This makes it possible for a setter to reject a change or transform/normalize a value
before assigning the value and this may not result in an actual change.</li>
<li>ðŸ’¥ <strong>[core]</strong> Replace usage of the <code>arez.Priority</code> enum with <code>arez.annotations.Priority</code> and <code>arez.spy.Priority</code>
and remove the <code>arez.Priority</code> class. The purpose is to migrate to where it is used and make it easy to identify
which code should be stripped during production compiles and under what circumstances. i.e. <code>arez.annotations.Priority</code>
should never be compiled to javascript and <code>arez.spy.Priority</code> should only be present if spies are enabled.</li>
<li>ðŸ’¥ <strong>[core]</strong> Rename the <code>canNestActions</code> parameter on the <code>@Autorun</code> and <code>@Track</code> annotation to
<code>nestedActionsAllowed</code> to align with underlying flags naming convention.</li>
<li>ðŸ’¥ <strong>[core]</strong> Rename the <code>@Autorun</code> annotation to <code>@Observed</code> to reflect naming conventions in the lower level
api and to prepare for merging with <code>@Tracked</code> annotation.</li>
<li>Update the <code>org.realityforge.guiceyloops:guiceyloops:jar</code> dependency to version <code>0.96</code>.</li>
<li>ðŸ’¥ <strong>[core]</strong> Rename the <code>onDepsUpdated</code> parameter to <code>onDepsChanged</code> to reflect conventions in the rest
of the codebase.</li>
<li>ðŸ’¥ <strong>[core]</strong> Rename <code>arez.annotations.ObservableRef</code> to <code>arez.annotations.ObservableValueRef</code>. The default
naming convention was also changed from <code>get[Name]Observable</code> to <code>get[Name]ObservableValue</code>.</li>
<li><strong>[core]</strong> Rename the <code>tracked</code> parameter on <code>ArezContext.observer(...)</code> methods to <code>observed</code> to align
with documentation.</li>
<li><strong>[core]</strong> Merge the <code>@Tracked</code> annotation into the <code>@Observed</code> annotation. This involved adding an additional
parameter <code>executor</code> that controls which actor is responsible for invoking the <code>@Observed</code> method. By default the
<code>executor</code> is set to <code>AREZ</code> which makes the invocation of the observed method the responsibility of the Arez
runtime. It can also be set to <code>APPLICATION</code> which means it is the responsibility of the application to invoke
the <code>@Observed</code> method. Previously you annotated a method with the <code>@Track</code> annotation which is equivalent to
annotating a method with <code>@Observed(executor=APPLICATION)</code>. The annotation processor was then updated to apply
different constraints on the method depending upon the value of the <code>executor</code> parameter. Support was also added
for the <code>reportParameters</code> parameter previously present on <code>@Track</code> annotation.</li>
<li><strong>[core]</strong> Rename the <code>ArezContext.track(...)</code> methods to <code>ArezContext.observe(...)</code>. This more accurately
reflects the intent of the operation.</li>
<li><strong>[core]</strong> If an application invoked <code>Observer.schedule()</code> on a non-STALE <code>Observer</code> with an <code>observed</code> method
and an <code>onDepsChanged</code> hook present then the next time that the <code>Observer</code> reacted to changes it would invoke the
<code>observed</code> method rather than the <code>onDepsChanged</code> as expected. This bug has been fixed.</li>
<li><strong>[core]</strong> Add support for the <code>arezOnlyDependencies</code> parameter to the <code>@Observed</code> that makes it possible to
specify the flags <code>AREZ_DEPENDENCIES_ONLY</code> and <code>NON_AREZ_DEPENDENCIES</code> when using the component model.</li>
<li><strong>[core]</strong> Introduce the <code>@ComponentIdRef</code> annotation that makes it possible to access the id of the component
without resorting to the <code>arez.component.Identifiable</code> interface which has some performance impact.</li>
<li><strong>[core]</strong> Fixed a bug where a component annotated with <code>@ArezComponent(nameIncludesId=false)</code> that also had a
<code>@Repository</code> annotation would always have an id of <code>0</code> in production mode.</li>
<li><strong>[core]</strong> The <code>Observer.schedule()</code>, <code>Observer.reportStale()</code> and <code>ComputedValue.reportPossibleChanged()</code>
did not register as usages of the transaction and thus actions that did not set <code>verifyActionRequired</code>
parameter to <code>false</code> would generate an invariant failure if the action only invoked these methods without also
accessing or mutating other observable state. These methods now mark the transaction as used so it is no longer
necessary to set <code>verifyActionRequired</code> to <code>false</code>.</li>
<li><strong>[core]</strong> Fixed bug where an action with <code>Flags.READ_ONLY</code> without the <code>Flags.REQUIRE_NEW_TRANSACTION</code> nested
in an action with the <code>Flags.READ_ONLY</code> flag would still create a new transaction. This has been fixed so that the
nested action no longer creates a new transaction.</li>
<li><strong>[core]</strong> Added new helper method <code>ArezContext.isReadOnlyTransactionActive()</code>.</li>
<li><strong>[core]</strong> Rename method <code>ArezContext.isWriteTransactionActive()</code> to <code>ArezContext.isReadWriteTransactionActive()</code>.</li>
<li><strong>[core]</strong> Changed the core api for invoking actions. Previously actions were created by passing a number
of boolean flags such as <code>mutation</code>, <code>verifyActionRequired</code> and <code>requireNewTransaction</code>. These have been collapsed
into a flags parameter that was moved after the executable parameter. The <code>parameters</code> parameter was changed from
a non-null, var-args parameter into a nullable array. Update the annotation processor to pass null if there are no
parameters or <code>Arez.areSpiesEnabled()</code> returns <code>false</code>. This improves the ability of the GWT compiler to optimize
and eliminate unused code.</li>
<li><strong>[core]</strong> Update the <code>ArezContext.observe(...)</code> and <code>ArezContext.safeObserve(...)</code> methods to change the last
parameter from a non-null, var args parameter into a nullable array. Makes the code easier for the GWT compiler
to optimize.</li>
<li><strong>[core]</strong> Remove the <code>ArezContext.noTxAction(...)</code> and <code>ArezContext.safeNoTxAction(...)</code> methods and associated
infrastructure for suspending and resuming transactions. The API was error prone and no use-case existed for the
functionality so it has been removed until such a time where a use-case is determined. Removal also resulted in a
decrease in code size when compiled using GWT.</li>
<li><strong>[core]</strong> Add a flag <code>Flags.AREZ_OR_NO_DEPENDENCIES</code> that makes it possible for observers that have not
specified the <code>Flags.SCHEDULED_EXTERNALLY</code> flag to have zero dependencies. An <code>Observer</code> or <code>ComputedValue</code>
that has zero dependencies will never be scheduled again but sometimes this is an expected scenario,
particularly as various elements of a reactive system are disposed.</li>
<li><strong>[core]</strong> Replace the <code>arezOnlyDependencies</code> on the <code>@Computed</code> and <code>@Observed</code> annotations with an
enumeration <code>DepType</code> that supports three values: <code>AREZ</code> (which has equivalent behaviour as the previous
<code>arezOnlyDependencies=true</code> parameter), <code>AREZ_OR_EXTERNAL</code> (which is equivalent behaviour as the previous
<code>arezOnlyDependencies=false</code> parameter) and <code>AREZ_OR_NONE</code> which expects that the observer or computed value
to be derived from arez dependencies <em>but</em> also allows the observer or computed value to have zero dependencies.</li>
<li><strong>[core]</strong> Start to enforce the constraint that application executed observed methods must complete having
accessed at least one dependency if the dependency type is <code>AREZ</code>. i.e. If a method annotated with
<code>@Observed( executor = Executor.APPLICATION, depType = DepType.AREZ )</code> does not access an observable an
invariant failure will be generated.</li>
<li><strong>[core]</strong> Rename the <code>@Dependency</code> annotation to <code>@ComponentDependency</code> to more accurately reflect intent.</li>
</ul>
</span></div></article></div><div class="post"><header class="postHeader"><h1><a href="/blog/2018/08/31/version-0.106-release.html">Arez 0.106 released</a></h1><p class="post-meta">August 31, 2018</p><div class="authorBlock"><p class="post-authorName"><a href="https://github.com/arez" target="_blank">Arez Project</a></p></div></header><article class="post-content"><div><span><p><a href="https://github.com/arez/arez/compare/v0.105...v0.106">Full Changelog</a></p>
<p>Changes in this release:</p>
<ul>
<li><strong>[core]</strong> Add invariant check that stops an observer's transaction from executing within the scope of
another transaction.</li>
<li><strong>[processor]</strong> The invariant check generated to verify the link step of references was being generated
outside of the associated guard resulting. This could result in dead-code not being eliminated in GWT2.x
and triggered warnings in source code analysis programs such as spotbugs.</li>
<li><strong>[core]</strong> Add an additional <code>ArezContext.computed(...)</code> method that takes a <code>arezOnlyDependencies</code> parameter.
The parameter defaults to <code>true</code> which means that the <code>ComputedValue</code> created expects the compute function to
access at least one Arez <code>ObservableValue</code> or <code>ComputedValue</code> within the scope of the function. It will also
generate an invariant failure if this is not the case and <code>apiInvariants</code> are enabled. The new parameter allows
the construction of <code>ComputedValue</code> instances that do not check invariants. This makes it possible for
<code>ComputedValue</code> instances to be derived from external, non-arez reactive elements that explicitly trigger changes
via <code>ComputedValue.reportPossiblyChanged()</code>. <code>ComputedValue.reportPossiblyChanged()</code> has also been changed
to generate an invarint failure if it is invoked and <code>arezOnlyDependencies</code> is <code>true</code>.</li>
<li><strong>[core]</strong> Add the <code>arezOnlyDependencies</code> parameter to the <code>@Computed</code> annotation and update the annotation
processor to support generate the supporting infrastructure. If the parameter is set to <code>false</code> the</li>
<li><strong>[gwt-output-qa]</strong> Fix assertions that broke due to rename of class <code>Observable</code> to <code>ObservableValue</code>.</li>
<li><strong>[core]</strong> Cache the <code>*Info</code> classes that are created for Arez elements <code>Component</code>, <code>ObservableValue</code>,
<code>ComputedValue</code>, <code>Observer</code> and <code>Transaction</code> when generating spy events or when interacting with a context
via the <code>arez.Spy</code> interface. This dramatically improves the performance during debugging by eliminating
excessive garbage collection. Assertions have been added to the <code>gwt-output-qa</code> module to ensure that the
cached fields never flow through into production code.</li>
<li><strong>[core]</strong> Add some additional tests of the external API of <code>arez.ArezContext</code>.</li>
<li><strong>[core]</strong> Change the way autorun observers and <code>keepAlive</code> computed values schedule their initial execution
if the <code>runImmediate</code> parameter is <code>true</code> to align between the low-level API in the <code>arez</code> package and the
way it was implemented in the component layer. Previously in the low-level API, the initial executions would
not be wrapped in a call to <code>arez.ReactionEnvironment</code> if it was present as they were invoked inline but they
would be wrapped in the component API. In the low-level API they would be invoked immediately regardless of
whether there was other higher priority reactions pending while the component API would schedule the reaction
and process the reactions using the normal scheduling priority ordering. The low-level API has been updated
to match the component API and will schedule the reaction using the standard mechanisms.</li>
<li><strong>[core]</strong> Add the <code>@CascadeDispose</code> annotation that can be applied to fields and will result in the
value being disposed when the component is disposed.</li>
<li><strong>[core]</strong> Add <code>ObserverInfo.isActive()</code> method so that the spy subsystem can inspect whether an observer
is active.</li>
<li><strong>[core]</strong> Improve invariant checking <code>Observer.setState(...)</code> so that any attempt to change from <code>DISPSOED</code>
to a non-<code>DISPOSED</code> state will generate in invariant failure.</li>
<li><strong>[core]</strong> Support passing in <code>arezOnlyDependencies</code> parameter when creating <code>track</code> and <code>autorun</code> observers.
This makes it possible for code to explicitly invoke the newly added method <code>Observer.reportStale()</code> to mark an
observer as stale and re-schedule the reaction associated with the observer. This makes it easier to access
non-arez dependencies in an observer and trigger the observer when the dependency changes.</li>
<li><strong>[core]</strong> Add the ability to pass in an <code>onDepsUpdated</code> hook to <code>ArezContext.autorun(...)</code> methods. This
hook method will be invoked when the system detects that dependencies have been updated but it is up to
non-arez code to invoke the newly added method <code>Observer.schedule()</code> that will schedule the observer. The
<code>schedule()</code> method will add the observer to the schedulers queue and trigger the scheduler
if it is not already active and not paused. It should be noted that invoking the <code>schedule()</code> method when the
observer has not been marked as <code>STALE</code> is effectively a no-op. The observer will be scheduled but when it comes
to invoke the observer, it will be skipped if it is <code>UP_TO_DATE</code>. This feature makes it possible for the arez
framework to manage execution of the observer and detection of dependency changes but make scheduling a
user-space concern. This makes it possible to debounce, throttle, delay etc. in application layer.</li>
<li><strong>[core]</strong> Add invariant check to verify that only the tracker associated with the current transaction can
be added as an observer to an observable.</li>
<li><strong>[core]</strong> Rename the <code>executable</code> parameter on <code>ArezContext.tracker(...)</code> methods to <code>onDepsUpdated</code> to align
with the terminology in the component model and indicate intent.</li>
<li><strong>[core]</strong> Rename the <code>executable</code> parameter on <code>ArezContext.autorun(...)</code> methods to <code>tracked</code> so that there
is consistent terminology within the core api.</li>
<li><strong>[core]</strong> Avoid emitting transaction mode in invariant failure messages when incorrect nesting of actions occur.</li>
</ul>
</span></div></article></div><div class="post"><header class="postHeader"><h1><a href="/blog/2018/08/23/version-0.105-release.html">Arez 0.105 released</a></h1><p class="post-meta">August 23, 2018</p><div class="authorBlock"><p class="post-authorName"><a href="https://github.com/arez" target="_blank">Arez Project</a></p></div></header><article class="post-content"><div><span><p><a href="https://github.com/arez/arez/compare/v0.104...v0.105">Full Changelog</a></p>
<p>Changes in this release:</p>
<ul>
<li><strong>[processor]</strong> Adding <code>@Deprecated</code> to methods annotated with <code>@ComponentId</code>, <code>@ComponentRef</code>,
<code>@ContextRef</code>, <code>@ContextTypeNameRef</code>, <code>@ComponentNameRef</code>, <code>@DependencyRef</code>, <code>@ObserverRef</code>, <code>@ObserverRef</code>
<code>@PreDispose</code> and <code>@PostDispose</code> no longer generates a compiler warning.</li>
<li><strong>[processor]</strong> Avoid name collisions in generated code between an existing constructor parameters name and
the name of an observable with an initializer by prefixing the synthesized name parameters in the generated
constructor with an arez prefix if the prefix is needed.</li>
<li><strong>[core]</strong> Document that <code>@ContextRef</code> annotation method must not have parameters.</li>
<li><strong>[core]</strong> Add the <code>Observable.reportObservedIfTracking()</code> method and use it from within generated code
to implement the <code>readOutsideTransaction</code> parameter on the <code>@Observable</code> annotation. This eliminates some code
duplication in generated classes and helps to reduce the code size when there is a large number of components.</li>
<li><strong>[core]</strong> Introduce the <code>@Reference</code> and <code>@ReferenceId</code> annotations that supports references
within an Arez component. A reference is retrieved from the <code>Locator</code> passed into the component using the type
returned by the <code>@Reference</code> annotated method and the id supplied by the <code>@ReferenceId</code> annotated method. The
lookup can occur lazily on access, eagerly on assign or with an explicit linking step. The <code>@ReferenceId</code>
annotated method can also be annotated with <code>@Observable</code> if the id can change over time, otherwise it is assumed
to return an immutable value.</li>
<li><strong>[core]</strong> Add the <code>arez.component.Linkable</code> interface to support explicit linking of references.</li>
<li><strong>[core]</strong> Add the <code>arez.component.Verifiable</code> interface to support explicit verification of components
internal state. The annotation processor will generate components that implement this interface if the processor
determines that the component needs verification. Verification can be enabled by changing the compile time constant
<code>&quot;&quot;arez.enable_verify&quot;</code> to <code>true</code>. This is done by default if you inherit the <code>arez.ArezDev</code> GWT module.</li>
<li><strong>[core]</strong> Add the <code>arez.Locator</code> interface to support lookup of references by type and id.</li>
<li><strong>[core]</strong> Add the <code>arez.component.TypeBasedLocator</code> implementation of <code>arez.Locator</code> that supports building
a locator from per-type lookup functions.</li>
<li><strong>[core]</strong> Add a compile configuration property <code>arez.enable_references</code> that defaults to <code>true</code> to enable or
disable support for references in the runtime. Setting the property to <code>false</code> when not needed will eliminate
unused reference support code.</li>
<li><strong>[core]</strong> Expose a per-context <code>arez.Locator</code> via <code>ArezContext.locator()</code>. This implementation delegates to
instances of <code>arez.Locator</code> registered via <code>ArezContext.registerLocator(...)</code>.</li>
<li><strong>[core]</strong> Add the <code>verify</code> parameter to the <code>@ArezComponent</code> annotation that controls whether the generated
component will implement the <code>arez.component.Verifiable</code> interface and perform verification at runtime.</li>
<li><strong>[processor]</strong> Update the compile time error generated when a component is empty so that it notes that if
<code>@Dependency</code> is present then the component is considered non-empty.</li>
<li><strong>[core]</strong> Add the ability to retrieve the priority of an observer or a computed using the spy subsystem via
either the <code>ObserverInfo.getPriority()</code> or the <code>ComputedValueInfo.getPriority()</code> methods.</li>
<li><strong>[core]</strong> Add the ability to supply an <code>onDispose</code> hook method when creating an <code>autorun</code> observer via
<code>ArezContext.autorun(...)</code>. This hook method is invoked when the observer is disposed.</li>
<li><strong>[core]</strong> The <code>&quot;when&quot;</code> observer that was previously part of the core Arez framework has been migrated to a
separate top-level project <code>arez-when</code>. The motivation for this was to reduce the complexity of the core and
only include elements that are broadly used and/or need to use internal APIs. The when observer was not broadly
used and exposing the <code>onDispose</code> hook method when creating autorun observers made it possible to implement this
functionality in a separate project.</li>
<li><strong>[core]</strong> Introduce the ability to pair <code>@Reference</code> methods with <code>@Inverse</code> so that the framework is able
to manage relationships in the reverse direction. For a complete description of this functionality, see the
javadocs and website documentation.</li>
<li><strong>[core]</strong> Update the javadocs for the <code>parameters</code> parameter passed to the <code>ArezContext.action(...)</code> and
<code>ArezContext.track(...)</code> methods to clearly articulate the the value is only used when generating spy events.</li>
<li><strong>[core]</strong> Use consistent terminology within <code>ArezContext</code>. The <code>@FunctionalInterface</code> interfaces (i.e.
<code>arez.Procedure</code>, <code>arez.SafeProcedure</code>, <code>arez.Function</code> and <code>arez.SafeFunction</code>) that are passed to the
<code>ArezContext.action(...)</code>, <code>ArezContext.autorun(...)</code> and <code>ArezContext.track(...)</code> methods as parameters
were previously named <code>action</code> which is confusing given that there is a separate domain concept for <code>Action</code>.
The parameters have been renamed to <code>executable</code> within the javadocs to reduce the potential for confusion.</li>
<li>Remove the <code>arez-entity</code> module as no longer needed once <code>@Reference</code> and <code>@Inverse</code> infrastructure has been
added to the library. This also involved merging the <code>integration-qa-support</code> module back into the
<code>integration-tests</code> module.</li>
<li><strong>[processor]</strong> Generate an invariant failure if the <code>allowEmpty</code> parameter of the <code>@ArezComponent</code> is
<code>true</code> but the component has methods annotated with arez annotations and thus is not considered empty.</li>
<li><strong>[core]</strong> Remove the <code>arez.annotations.OnDispose</code> annotation as the same behaviour can be achieved by
the use of <code>@PreDispose</code> and/or <code>@PostDispose</code> and this results in a more consistent mechanism for hooking
into the component dispose mechanisms.</li>
<li><strong>[processor]</strong> Omit the <code>protected</code> access modifier on the constructor of generated component classes as
the generated classes are <code>final</code> and thus the <code>protected</code> access modifier is equivalent to package access.</li>
<li><strong>[processor]</strong> Omit the <code>public</code> access modifier on the constructor of generated component classes if
the component class is not <code>public</code>.</li>
<li><strong>[processor]</strong> Add the <code>public</code> access modifier to a generated component classes if it has a <code>@Inverse</code>
annotated method that has a target type in a different package and the component class does not have a public
constructor. This is required so that the generated classes can interact with the synthetic methods added
to component class to manage the inverse.</li>
<li><strong>[processor]</strong> Fix bug where an <code>@Observable</code>, <code>@Nullable</code> property would be generated requiring that a
non-null value passed into the initializer.</li>
<li><strong>[gwt-output-qa]</strong> Add assertion to <code>arez.gwt.qa.ArezBuildAsserts</code> that ensures that the method
<code>arez.Observable.preReportChanged()</code> is not present in production code.</li>
<li><strong>[gwt-output-qa]</strong> Add assertion <code>arez.gwt.qa.ArezBuildAsserts.assertEquals(...)</code> that can be used to
ensure generated classes do or do not have equals defined. Add assertions into standard asserts that ensure
that no repositories have an <code>equals(...)</code> method defined.</li>
<li>ðŸ’¥ <strong>[core]</strong> Rename <code>ArezContext.computedValue(...)</code> methods to <code>ArezContext.computed(...)</code> for consistency.
Rename the value of the <code>type</code> property in the serialization of <code>ComputedValue</code> spy events from <code>computedValue</code>
to <code>computed</code>.</li>
<li><strong>[core]</strong> The <code>OnStale</code>, <code>OnActivate</code>, <code>OnDeactivate</code> and <code>OnDispose</code> hook methods that can be added to an
instance of <code>arez.ComputedValue</code> and the <code>OnDispose</code> hook method that can be added to <code>arez.Observer</code> are only
set on the object if the hooks are non-null. In some scenarios this decreased runtime memory usage with the
potential for a slight increase in code size in some applications. It should be noted that In J2CL, this change
actually resulted in a code size decrease if the application does not make use of the hooks.</li>
<li><strong>[core]</strong> Move the <code>OnStale</code>, <code>OnActivate</code> and <code>OnDeactivate</code> hook methods from <code>arez.Observer</code> to
<code>arez.ComputedValue</code> to decrease memory pressure at runtime as the hooks are not required except for computed
properties.</li>
<li><strong>[core]</strong> Move the field referencing the <code>Observable</code> from the <code>arez.Observer</code> class to the <code>ComputedValue</code>
class. This reduces the runtime overhead associated with non-computed observers as well as reducing the code
size. This does result in the <code>Observer</code> associated with the <code>ComputedValue</code> being disposed after the <code>Observable</code>
associated with the <code>ComputedValue</code>. However the only external impact of this change is a re-ordering of the spy
events generated by these activities.</li>
<li><strong>[core]</strong> Add the method <code>ComputedValue.reportPossiblyChanged()</code> that makes it possible for developers to
explicitly trigger an update of a computed property that is derived from non-arez dependencies.</li>
<li><strong>[processor]</strong> Remove empty statement in generated <code>equals()</code> method. This triggers warnings and/or errors in
several source code analysis tools. This is usually not a problem as it is generated code from an annotation
processor but recent updates to the tool chains can add the generated source code to analysis paths in some
circumstances.</li>
<li><strong>[core]</strong> Replace the usage of the <code>_disposed</code> an <code>_disposing</code> fields on <code>Observer</code> with existing <code>_state</code>
field. This reduces the runtime memory size of the <code>Observer</code> object by eliminating two properties.</li>
<li>ðŸ’¥ <strong>[core]</strong> Rename the class <code>arez.Observable</code> to <code>arez.ObservableValue</code> and rename supporting classes and
methods. The API changes include;
<ul>
<li>Rename interface <code>arez.spy.ObservableInfo</code> to <code>arez.spy.ObservableValueInfo</code>.</li>
<li>Rename method <code>asObservableValueInfo(...)</code> to <code>asObservableValueInfo(...)</code> on the class <code>arez.Spy</code>.</li>
<li>Rename class <code>arez.spy.ObservableChangedEvent</code> to <code>arez.spy.ObservableValueChangeEvent</code>.</li>
<li>Rename class <code>arez.spy.ObservableCreatedEvent</code> to <code>arez.spy.ObservableValueCreateEvent</code>.</li>
<li>Rename class <code>arez.spy.ObservableDisposedEvent</code> to <code>arez.spy.ObservableValueDisposeEvent</code>.</li>
<li>Rename the type field in serialized form of the <code>arez.spy.Observable*Event</code> classes to replace
<code>Observable...</code> with <code>ObservableValue...</code>.</li>
</ul></li>
<li>ðŸ’¥ <strong>[core]</strong> Remove the unused class <code>arez.component.AbstractEntityReference</code>.</li>
<li>ðŸ’¥ <strong>[core]</strong> Add tests covering the spy events <code>arez.spy.*Event</code>.</li>
<li>ðŸ’¥ <strong>[core]</strong> Change the <code>arez.spy.Component*Event</code> spy events to use <code>ComponentInfo</code> rather than <code>Component</code>.</li>
<li>ðŸ’¥ <strong>[core]</strong> Replace usage of the <code>arez.annotations.Priority</code> enum with <code>arez.Priority</code> and remove
the <code>arez.annotations.Priority</code> class.</li>
<li><strong>[processor]</strong> Generate an error if a component sets the <code>allowConcrete</code> to <code>true</code> in the <code>@ArezComponent</code>
annotation but is actually an abstract class.</li>
</ul>
</span></div></article></div><div class="post"><header class="postHeader"><h1><a href="/blog/2018/08/01/version-0.104-release.html">Arez 0.104 released</a></h1><p class="post-meta">August 1, 2018</p><div class="authorBlock"><p class="post-authorName"><a href="https://github.com/arez" target="_blank">Arez Project</a></p></div></header><article class="post-content"><div><span><p><a href="https://github.com/arez/arez/compare/v0.103...v0.104">Full Changelog</a></p>
<p>Changes in this release:</p>
<ul>
<li><strong>[core]</strong> Add the <code>priority</code> and <code>observeLowerPriorityDependencies</code> parameters to the <code>@Memoize</code>
annotation. These parameters control the same named parameters on the <code>ComputedValue</code> instances created
by the <code>MemoizeCache</code>.</li>
<li><strong>[processor]</strong> Change the annotation processor so that only whitelisted annotations are copied to
subclasses and overridden methods. The whitelisted annotations include <code>javax.annotations.Nonnull</code>,
<code>javax.annotations.Nullable</code> and <code>java.lang.Deprecated</code>.</li>
</ul>
</span></div></article></div><div class="post"><header class="postHeader"><h1><a href="/blog/2018/07/30/version-0.103-release.html">Arez 0.103 released</a></h1><p class="post-meta">July 30, 2018</p><div class="authorBlock"><p class="post-authorName"><a href="https://github.com/arez" target="_blank">Arez Project</a></p></div></header><article class="post-content"><div><span><p><a href="https://github.com/arez/arez/compare/v0.102...v0.103">Full Changelog</a></p>
<p>Changes in this release:</p>
<ul>
<li><strong>[core]</strong> Add the utility method <code>ArezContext.isTrackingTransactionActive()</code>.</li>
<li><strong>[core]</strong> Change the implementation of <code>readOutsideTransaction</code> parameter on the <code>@Observable</code>
annotation so that <code>arez.Observable.reportObserved()</code> will only be invoked in a tracking transaction
(i.e. when an <code>arez.Observer</code> created the transaction). Thus <code>@Action</code> annotated methods that only
access observables that set the <code>readOutsideTransaction</code> parameter to <code>true</code> and and neither access
nor modify other arez elements no longer need to be annotated with <code>@Action</code> annotations.</li>
</ul>
</span></div></article></div><div class="post"><header class="postHeader"><h1><a href="/blog/2018/07/26/version-0.102-release.html">Arez 0.102 released</a></h1><p class="post-meta">July 26, 2018</p><div class="authorBlock"><p class="post-authorName"><a href="https://github.com/arez" target="_blank">Arez Project</a></p></div></header><article class="post-content"><div><span><p><a href="https://github.com/arez/arez/compare/v0.101...v0.102">Full Changelog</a></p>
<p>Changes in this release:</p>
<ul>
<li><strong>[core]</strong> Add the <code>readOutsideTransaction</code> parameter to the <code>@Observable</code> annotation. If set to <code>true</code>
the observable can be read outside a transaction. i.e. The observable can be read without be wrapping in a
<code>@Computed</code> method, a <code>@Autorun</code> method, a <code>@Track</code> method or an <code>@Action</code> method. The read of an observable
within a tracking transaction will continue to record the access as a dependency on the tracker.</li>
<li><strong>[core]</strong> Add the utility method <code>ArezContext.isWriteTransactionActive()</code>.</li>
<li><strong>[core]</strong> Add the <code>requireNewTransaction</code> parameter to the <code>@Action</code> annotation. If set to <code>true</code> then
an action always creates a new transaction to wrap the action. If set to false then the action will use the
current transaction if a transaction is active and create a new transaction if no transaction is active.
Add the same parameter to the <code>ArezContext.action(...)</code> and <code>ArezContext.safeAction(...)</code> methods.</li>
<li><strong>[core]</strong> Change the default value of the <code>requireNewTransaction</code> parameter on the <code>@Action</code> annotation
from <code>false</code> to <code>true</code>.</li>
<li><strong>[core]</strong> Add an additional invariant check to ensure that <code>ComputedValue</code> actions do not attempt to
invoke actions or track functions. The intent of <code>ComputedValue</code> is to derive values from observable and
computed properties and not to drive change (i.e. actions) or react to change (i.e. track methods).</li>
<li><strong>[core]</strong> Add the <code>canNestActions</code> parameter to the <code>@Track</code> and <code>@Autorun</code> annotations. If the parameter
is false, then an invariant failure will occur if the track or autorun observers attempt to invoke an action.
The intent is to force the developer to explicitly allow this scenario as nested actions can impact the
dependencies of the containing observer.</li>
</ul>
</span></div></article></div><div class="post"><header class="postHeader"><h1><a href="/blog/2018/07/25/version-0.100-release.html">Arez 0.100 released</a></h1><p class="post-meta">July 25, 2018</p><div class="authorBlock"><p class="post-authorName"><a href="https://github.com/arez" target="_blank">Arez Project</a></p></div></header><article class="post-content"><div><span><p><a href="https://github.com/arez/arez/compare/v0.99...v0.100">Full Changelog</a></p>
<p>Changes in this release:</p>
<ul>
<li><strong>[downstream-test]</strong> Test against output of J2CL over time to ensure that no size regressions occur.</li>
<li>Update the release process to remove artifacts staged in previous releases.</li>
<li><strong>[processor]</strong> Change the mechanisms via which <code>@ArezComponent( disposeOnDeactivate = true )</code> is
implemented so that the reaction scheduling the dispose is at a <code>HIGHEST</code> priority. This will avoid the
scenario where <code>@Autorun</code> and <code>@Computed</code> methods react on a component that will be disposed because it
is no longer being observed.</li>
<li><strong>[processor]</strong> Fix a bug that would result in an invariant failure when creating top-level arez elements
(i.e. those without an associated native component) when <code>Arez.areNativeComponentsEnabled()</code> returns false
but <code>Arez.areRegistriesEnabled()</code> returns true.</li>
<li><strong>[core]</strong> Add support for the <code>requireId</code> parameter on the <code>@ArezComponent</code> annotation. The default value
is <code>AUTODETECT</code> which is equivalent to existing behaviour. It is also possible to explicitly enable ids which
is particularly useful when building custom repository-like classes.</li>
<li><strong>[processor]</strong> Improve the invariant message to include the component name when the component id is
accessed when it is not expected to be accessed.</li>
<li><strong>[core]</strong> If an <code>ArezContext</code> has a <code>ReactionEnvironment</code> configured and the environment schedules
reactions after the call to the action that runs the scheduler, the runtime will now detect that the
scheduler has tasks that need to be scheduled and immediately invoke the scheduler again until there are
no tasks that need scheduling.</li>
<li><strong>[core]</strong> Introduce a <code>HIGHEST</code> priority so that reactions that schedule the de-allocation of resources
can be scheduled at a higher priority than <code>HIGH</code> priority reactions.</li>
</ul>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev" href="/blog/page6/">â† Prev</a><a class="docs-next" href="/blog/page8/">Next â†’</a></div></div></div></div></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/" class="nav-home"><img src="/img/logo.svg" alt="Arez" width="66" height="58"/></a><div><h5>Docs</h5><a href="/docs/overview.html">Overview</a><a href="/docs/concepts.html">Concepts</a><a href="/api/index.html">API Reference</a></div><div><h5>More</h5><a href="/blog">Blog</a><a href="https://github.com/">GitHub</a><a class="github-button" href="https://github.com/arez/arez" data-icon="octicon-star" data-count-href="/arez/arez/stargazers" data-show-count="true" data-count-aria-label="# stargazers on GitHub" aria-label="Star this project on GitHub">Star</a></div></section><section class="copyright">Copyright Â© 2020 the Arez Project.</section></footer></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
              var search = docsearch({
                apiKey: 'b8c49751e0914443436822868f0c5000',
                indexName: 'arez',
                inputSelector: '#search_input_react'
              });
            </script></body></html>